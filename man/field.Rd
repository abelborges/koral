% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Field.R
\name{Field}
\alias{Field}
\alias{StringField}
\alias{StringArrayField}
\alias{EnumField}
\alias{DoubleField}
\alias{DoubleArrayField}
\alias{IntegerField}
\alias{IntegerArrayField}
\alias{BigIntField}
\alias{BigIntArrayField}
\alias{DateField}
\alias{DateArrayField}
\alias{TimestampField}
\alias{TimestampArrayField}
\alias{UuidField}
\alias{UuidPrimaryKey}
\alias{timestamps}
\title{Base field declaration constructor}
\usage{
Field(
  name = NULL,
  type = NULL,
  pk = FALSE,
  fk = NULL,
  default = function() NULL,
  nullable = FALSE,
  unique = FALSE,
  transient = FALSE,
  updatable = TRUE,
  update_trigger = NULL,
  parser = NULL,
  db_parser = identity,
  db_check = NULL,
  deduced = FALSE
)

StringField(name, parser = function(x) as.character(x[[name]])[1], ...)

StringArrayField(name, parser = function(x) as.character(x[[name]]), ...)

EnumField(name, values, parser = function(x) as.character(x[[name]])[1], ...)

DoubleField(name, parser = function(x) as.numeric(x[[name]])[1], ...)

DoubleArrayField(name, parser = function(x) as.numeric(x[[name]]), ...)

IntegerField(name, parser = function(x) as.integer(x[[name]])[1], ...)

IntegerArrayField(name, parser = function(x) as.integer(x[[name]]), ...)

BigIntField(name, parser = function(x) bit64::as.integer64(x[[name]])[1], ...)

BigIntArrayField(
  name,
  parser = function(x) bit64::as.integer64(x[[name]]),
  ...
)

DateField(
  name,
  parser = function(x) .date_parser(as.character(x[[name]]))[1],
  ...
)

DateArrayField(
  name,
  parser = function(x) .date_parser(as.character(x[[name]])),
  ...
)

TimestampField(
  name,
  parser = function(x) .timestamp_parser(as.character(x[[name]]))[1],
  ...
)

TimestampArrayField(
  name,
  parser = function(x) .timestamp_parser(as.character(x[[name]])),
  ...
)

UuidField(name, parser = function(x) as.character(x[[name]])[1], ...)

UuidPrimaryKey(name, ...)

timestamps()
}
\arguments{
\item{name}{Field name.}

\item{type}{Field PostgreSQL type.}

\item{pk}{Logical. Is it part of the relation's Primary Key?}

\item{fk}{Set to a \code{ForeignKey}-returned object in case the field is constrained to
the values of a field in another relation.}

\item{default}{Fill with either a function or a value to be used in \code{INSERT} queries
in case input data skips this field.}

\item{nullable}{Logical. Is it allowed to be null?}

\item{unique}{Logical. Should there be a 1:1 mapping between the field and the PK?}

\item{transient}{Logical. Is it saved to the database? E.g., you probably want to
declare raw password fields with \code{transient = TRUE}, so that they
are encrypted before being persisted.}

\item{updatable}{Logical. Is it allowed to be updated after record creation?}

\item{update_trigger}{Fill with a 0-parameter function whose return value is used
to update the field during \code{UPDATE} queries.}

\item{parser}{Function of a named list representing a record whose return value is
the parsed field value. This is called whenever \code{{koral}} is about to
commit a write (insert or update) to the database.}

\item{db_parser}{Function of the field's name used to wrap the field's value in a
database function during writes.}

\item{db_check}{Optional string with PostgreSQL \code{CHECK} constraint expression. E.g.
\code{Field("positive", "NUMERIC", db_check = "CHECK (positive > 0)")}.}

\item{deduced}{Logical. Is it deduced from other fields (by \code{parser})? For instance,
\verb{Field("hashed_x", "TEXT", deduced = TRUE, parser = \\(dto) hash(dto$x))}.}
}
\value{
A \code{koral_field} object.
}
\description{
Use \code{Field} directly only for non-trivial cases.
Otherwise, checkout higher-level constructors such as
\code{UuidPrimaryKey}, \code{StringField}, \code{EnumField}, \code{timestamps} etc.
}
